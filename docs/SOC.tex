\documentclass[a4paper,12pt]{article}
\usepackage[margin=25mm]{geometry}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[backend=bibtex,sorting=none]{biblatex}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage[nounderscore]{syntax}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{array}

\definecolor{keyword}{RGB}{0, 64, 255}

\addbibresource{SOC.bib}

\def\circumflex{\char`\^}
\def\quote #1{"#1"}
\def\keyword #1{\color{keyword}#1\color{black}}
\def\emphasis #1{\textbf{\texttt{\quote{#1}}}}
\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$-$}
\makeatletter
\newcount\my@repeat@count
\newcommand{\repeatchar}[2]{
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}
  \endgroup
}
\makeatother

\author{Richard Blažek}
\setlength{\headheight}{15pt}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[R]{Překladač jazyka Zyba}
\fancyhead[L]{Richard Blažek}
\fancyfoot{}
\fancyfoot[R]{\thepage}
\fancyfoot[L]{Kapitola \thesection}
\setlength\parindent{0em}
\setlength\parskip{0.8em}
\def\arraystretch{1.2}

\begin{document}
\begin{titlepage}
    \begin{center}

	\vspace*{3.5cm}            
	\Huge
	\textbf{Překladač jazyka Zyba}
            
	\vspace{0.5cm}
	\LARGE
	Staticky typovaný jazyk kompilovaný do PHP
        
	\vspace*{1.5cm}
	\Huge
	\textbf{Zyba language compiler}
            
	\vspace{0.5cm}
	\LARGE
	Language with static typing transpiled into PHP
            
	\vfill
            
	\large
        Středoškolská odborná činnost, rok 2022\\
	Richard Blažek\\
	Gymnázium Brno, třída Kapitána Jaroše 14
    \end{center}
\end{titlepage}
\thispagestyle{empty}
\Large\textbf{Prohlášení}\normalsize

Prohlašuji, že jsem svou závěrečnou maturitní práci vypracoval samostatně a použil jsem pouze prameny a literaturu uvedené v~seznamu bibliografických záznamů.

Prohlašuji, že tištěná verze a elektronická verze závěrečné maturitní práce jsou shodné.

Nemám závažný důvod proti zpřístupňování této práce v~souladu se zákonem č. 121/2000 Sb., o~právu autorském, o~právech souvisejících s~právem autorským a o~změně některých zákonů (autorský zákon) ve~znění pozdějších předpisů. 

V~Brně dne \today{} \repeatchar{40}{.}
\newpage
\thispagestyle{empty}
\Large\textbf{Poděkování}\normalsize

Tímto bych chtěl poděkovat Matěji Žáčkovi za odborné vedení práce.
\newpage
\thispagestyle{empty}
\Large\textbf{Anotace}\normalsize

Práce se zabývá navržením jazyka Zyba a implementací překladače tohoto jazyka do PHP, což by mělo umožnit používání tohoto jazyka na všech webhostinzích, které podporují PHP skripty. Rovněž bude možné vyvíjet část projektu v Zybě a část v PHP a používat funkce z jednoho jazyka ve druhém.

\Large\textbf{Klíčová slova}\normalsize

programovací jazyk; překladač; transpiling; webová aplikace; PHP; Zyba

\Large\textbf{Annotation}\normalsize

The thesis is concerned with the design of the Zyba language and implementing its compiler. The compiler generates PHP code, making it possible for the language to be used on all webhostings where PHP is supported. Also, it will be possible to combine Zyba and PHP when developing web applications and use functions from one of the languages in the other one.

\Large\textbf{Keywords}\normalsize

programming lanugage; compiler; transpiling; web application; PHP; Zyba
\newpage
\thispagestyle{empty}
\tableofcontents
\newpage
\section{Úvod}
Cílem této práce je navrhnout programovací jazyk Zyba, který by měl umožnit psaní přehlednějšího kódu než PHP, a implementovat překladač ze Zyby do PHP, aby bylo možné programy v Zybě používat na všech na všech serverech s podporou PHP skriptů. Navrhl jsem Zybu jako staticky typovaný jazyk, protože překlad z jednoho dynamicky typovaného jazyka do druhého by umožnil provádět při překladu pouze syntatickou kontrolu. K vyhodnocení typů by mohlo dojít až za běhu programu a Zyba by tak představovala jen alternativní syntaxi pro PHP. Zybu jsem navrhl jako jazyk jednoduchý na naučení, ale s dostatečnou funkcionalitou pro psaní webových stránek.

Překladač jsem se rozhodl napsat v jazyce Haskell, protože umožňuje psát velmi stručné a přehledné programy. K čitelnosti programu přispívá jednak syntaxe jazyka, v němž se struktura programu vyjadřuje formátováním zdrojového kódu a ne oddělovači, jednak jeho striktní dodržování funkcionálního paradigmatu, které vyžaduje, aby funkce byly referenčně transparentní (tzn. bez vedlejších efektů). Navíc jeho typový systém obsahuje algebraické datové typy a umožňuje zápis rekurzivních typů, což se u překladače hodí například na zápis syntaktického stromu.

\section{Návrh jazyka}
\subsection{Syntaxe}
Syntaxe Zyby je stejně jako u řady dalších jazyků (např. C++, Java, C\#, JavaScript) odvozená z jazyka C, aby byla blízká ostatním programátorům, ale liší se v řadě detailů. Všechny operátory jsou binární, zleva asociativní a mají stejnou prioritu. Práce s poli a slovníky (tj. jejich vytváření a přístup k prvkům a jejich změna) není záležitostí speciální syntaxe, ale provádí se zabudovanými metodami až na úrovni sémantiky. Volání funkce je vyjádřeno hranatými závorkami. Díky těmto změnám je syntaxe jednoznačná, aniž by musel uživatel používat středníky. Středníky a čárky jsou považovány za bílé znaky, takže je možné je používat, kde to programátor uzná za vhodné pro přehlednost kódu. Komentáře jsou jednořádkové a začínají křížkem (\texttt{\#}).

Následuje popis prvků syntaxe a její formální popis v rozšířené Backus-Naurově formě.

\subsubsection{Deklarace}
Soubor v Zybě se skládá z deklarací. Každá deklarace buď přiřadí určité globální konstantě hodnotu určitého výrazu, nebo importuje deklarace z jiného souboru. Importují se přitom pouze ty deklarace, které byly uvozeny slovem \texttt{export}
\begin{grammar}
<file> ::= ((\emphasis{export})? <declaration>)*

<declaration> ::= <assignment> | <import>

<assignment> ::= <name> \emphasis{=} <expression>
\end{grammar}

Importovat lze jak ze Zyby tak i z PHP. Import ze Zyby vyžaduje cestu k souboru, který má být importován, a název jmenného prostoru, do kterého budou importované hodnoty spadat. Import z PHP to vyžaduje rovněž, ale před názvem jmenného prostoru musí být napsáno slovo \texttt{php} a za cestou k souboru musí následovat záznam se jmény a typy importovaných hodnot. Záznam tvoří složené závorky a v nich několik dvojic názvů (tj. jména importovaných hodnot) a výrazů (tj. jejich typy).
\begin{grammar}
<import> ::= <import-zyba> | <import-php>

<import-zyba> ::= \emphasis{import} <name> <literal-text>

<import-php> ::= \emphasis{import php} <name> <literal-text> <record>

<record> ::= \emphasis{\{} (<name> <expression>)* \emphasis{\}}
\end{grammar}

\subsubsection{Výrazy}
Výraz tvoří jeden či více podvýrazů oddělených binárními operátory. Podvýraz tvoří jednotka, kterou můžou následovat volání funkce a přístupy k prvkům záznamu nebo jmenného prostoru. Volání funkce tvoří několik výrazů v hranatých závorkách; přístup k prvku tvoří tečka následovaná jménem. Zabudované metody se volají způsobem, který kombinuje syntaxi přístupu a syntaxi volání funkce: \texttt{argument1.metoda[argument2 \ldots{} argument\textsubscript{N}}, přičemž mají-li jen jeden argument, je možné závorky vynechat.
\begin{grammar}
<expression> ::= <call> (<operator> <call>)*

<subexpression> ::= <unit> (<call> | <access>)*

<call> ::= \emphasis{[} <expression>* \emphasis{]}

<access> ::= \emphasis{.} <name>
\end{grammar}

Jednotek je několik druhů: výraz v závorkách; literál celého čísla, reálného čísla, logické hodnoty či text; záznam nebo lambda funkce.
\begin{grammar}
<unit> ::= \emphasis{(} <expression> \emphasis{)}

<unit> ::= <literal-int> | <literal-real> | <literal-bool> | <literal-text>

<unit> ::= <record>

<unit> ::= <lambda>
\end{grammar}

\subsubsection{Funkce a příkazy}
Lambda funkce začíná slovem \texttt{fun}. Následují argumenty funkce v hranatých závorkách, výraz specifikující typ navrácené hodnoty a blok, který tvoří několik příkazů ve složených závorkách. Argumenty funkce, pokud nějaké jsou, se zapisují po skupinách, z nichž každá se skládá z názvů jednoho či více argumentů následovaných dvojtečkou a výrazem specifikujícím typ těchto argumentů.
\begin{grammar}
<lambda> ::= \emphasis{fun} \emphasis{[} <arguments> \emphasis{]} <expression> <block>

<arguments> ::= (<name>+ \emphasis{:} <expression>)*

<block> ::= \emphasis{\{} <statement>* \emphasis{\}}
\end{grammar}

Příkazem může být výraz, jenž má být vyhodnocen, přiřazení, příkaz \texttt{if} nebo cyklus \texttt{while}. Příkaz \texttt{if} začíná slovem \texttt{if} následovaným výrazem (podmínkou) a blokem příkazů; za blokem můžou následovat další části, jež začínají slovy \texttt{else if} a rovněž pokračují podmínkou a blokem příkazů; poté může následovat slovo \texttt{else} následované blokem, který se provede, pokud žádná z předchozích podmínek nebyla splněna. Cyklus \texttt{while} začíná slovem \texttt{while} následovaným výrazem (podmínkou) a blokem příkazů.
\begin{grammar}
<statement> ::= <expression> | <assignment> | <if> | <while>

<if> ::= \emphasis{if} <condition> <block> (\emphasis{else if} <condition> <block>)* (\emphasis{else} <block>)?

<while> ::= \emphasis{while} <condition> <block>
\end{grammar}

\subsubsection{Tokeny}
Nejmenší jednotkou syntaxe jsou tokeny. Token může být jedno z následujících:
\begin{itemize}
\item \textbf{Jméno} je posloupnost znaků, jež obsahuje pouze číslice, malá a velká písmena latinky a podtržítka a jejíž první znak není číslice.
\item \textbf{Literál celého čísla} je buď posloupnost dekadických číslic tvořící číslo, nebo posloupnost dekadických číslic, udávající základ číselné soustavy, a po ní znak \texttt{r} a posloupnost číslic z oné číselné soustavy, písmena A až Z bez ohledu na velikost se považují za číslice 10 až 35. Lze používat i soustavy o základu vyšším než 36, ale není v nich možné zapsat všechna čísla protože pro ně nejsou další číslice.
\item \textbf{Literál reálného čísla} začíná jako literál celého čísla, ale pokračuje desetinnou tečkou po které můžou následovat další číslice. Rovněž lze používat libovolnou číselnou soustavu.
\item \textbf{Literál logické hodnoty} je \texttt{1b} pro pravdu a \texttt{0b} pro nepravdu. Je to totiž kratší než tradiční \texttt{true} a \texttt{false} a navíc je zápis obou hodnot stejně dlouhý.
\item \textbf{Literál textu} je posloupnost znaků v uvozovkách. Patří do něj všechny znaky mezi nimi, tedy i konce řádků a speciální znaky, ale je-li potřeba zapsat znak uvozovek, musí se zdvojit, aby nedošlo k ukončení literálu.
\item \textbf{Operátor} je libovolná poslounost znaků \uv{\texttt{+-*/\%\&|\textasciitilde\circumflex<>=!}}. Jestli dotyčný operátor opravdu existuje a lze jej aplikovat na tyto argumenty se posoudí až při vyhodnocování sémantiky.
\item \textbf{Oddělovač} je jeden znak; některý ze znaků \uv{\texttt{()[]\{\}.:}}.
\end{itemize}

\subsubsection{Příklad}
\begin{verbatim}
# Toto je komentář
# Deklarace konstant
a = 1103515245
# 12345 zapsané v osmičkové soustavě
c = 8r30071
# Tady využíváme literály v soustavě o základu 256
# Číslice 36 až 255 neexistují, ale toto číslo je nepotřebuje
m = 256r10000
# Pokud je poslední příkaz ve funkci vyhodnocení výrazu,
# vrátí se hodnota toho výrazu
next = fun[x: int] int {
    x * a + c % m
}
# Zápis funkce s více argumenty
mocnina = fun[zaklad exp: int] int {
    result = 1
    while exp > 0 {
    	result = result * zaklad
    	exp = exp - 1
    }
    result
}
\end{verbatim}

\subsection{Kontext}
Každé jméno v kódu překladač vyhodnoduje v určitém kontextu, který zahrnuje všechna jména, jež na daném místě v kódu označují nějakou proměnnou, konstantu či jmenný prostor. Proměnné i konstanty jsou jména zastupující určitou hodnotu. Jmenný prostor je kolekce obsahující další proměnné, konstanty a jmenné prostory, k nimž se přistupuje skrz onen jmenný prostor.

Proměnná se vytváří uvnitř bloku příkazů přiřazením hodnoty určitému jménu, jenž na daném místě ještě nic neoznačuje, a je přístupné až do konce toho bloku. Argumenty lambda funkcí jsou rovněž proměnné, jejichž hodnoty se nastaví při zavolání funkce na hodnoty předaných argumentů a jsou dostupné uvnitř celé lambda funkce. Proměnnou jde změnit tím, že se do ní přiřadí nová hodnota; ta musí mít stejný typ jako předchozí hodnota proměnné, kterou nová hodnota nahradila.

Konstanta se deklaruje přiřazením na úrovni souboru, tedy vně všech bloků příkazů, a je dostupná od přiřazení až po konec souboru. Pokud přiřazenou hodnotou je lambda funkce, je konstanta přístupná v celém souboru, tedy už před přiřazením a dokonce i v těle té lambda funkce samotné. Jednou vytvořené konstantě už není možné přiřadit novou hodnotu a není možné vytvořit ani jmenný prostor se stejným názvem.

Jmenný prostor vzniká při importu z jiného souboru a obsahuje všechny exportované konstanty a jmenné prostory deklarované v onom souboru. Od dotyčného importu do konce souboru přes něj lze přistupovat k jeho prvkům pomocí již zmiňované syntaxe \texttt{prostor.prvek}. Obsahuje-li jmenný prostor další exportované jmenné prostory, lze přístupy zřetězit a přistupovat i k jejich prvkům: \texttt{prostor1.prostor2.prostor3.prvek}. Žádné dva jmenné prostory nemůžou 

\subsection{Typový systém}
Zyba je staticky typovaný jazyk se silnou typovou kontrolou; typy všech hodnot tedy musí být známy v čase překladu a nemůžou se implicitně konvertovat. Pro konverzi hodnoty z jednoho typu na druhý lze použít zabudované metody, pokud programátor nechce konverzi implementovat ručně. Určitou zvláštností Zyby je to, že v místě, kde je očekáván typ, se dá použít libovolná hodnota onoho typu (např. hodnota \texttt{3+4} se dá použít jako typ \texttt{int}). Jména \texttt{int}, \texttt{bool} a další totiž ve skutečnosti znamenají pouze výchozí hodnoty těchto typů, nikoliv typy samotné (např. \texttt{int} je totéž jako \texttt{0}). Samozřejmě by se při psaní kódu měly používat názvy typů na místech, kde je očekáván typ, a hodnoty na místech, kde je očekávána hodnota; je sice možné to nedodržovat, ale vzniklý kód bude matoucí. Tato zvláštnost ale má i některé výhody, protože jednak činí jazyk jednodušším a navíc umožňuje vytvářet typové aliasy úplně stejně jako se vytváří proměnné a konstanty. Ostatně tento přístup má určitou paralelu v chování některých objektově orientovaných jazyků (např. C++\cite{cpp}), které umožňují volat statické metody jak na třídě, tak i na objektu; i v nich se tedy dá někdy použít hodnota (objekt) na místo typu (třídy).

\subsubsection{Datové typy}
\begin{tabular}{|m{3.5cm} m{6cm} m{5cm}|}\hline
Název & Popis & Výchozí hodnota \\\hline
\texttt{void} & Prázdná hodnota, návratový typ funkcí, které nic nevracejí & Bezvýznamná hodnota\\\hline
\texttt{int} & Celé číslo, 32bitové nebo 64bitové v závislosti na systému & Nula (\texttt{0})\\\hline
\texttt{real} & Reálné číslo & Nula jako reálné číslo (\texttt{0.0})\\\hline
\texttt{bool} & Logická hodnota & Nepravda (\texttt{0b})\\\hline
\texttt{text} & Textový řetězec & Prázdný text (\texttt{\quote{}})\\\hline
\texttt{T.list} & Pole hodnot typu \texttt{T} & Prázdné pole\\\hline
\texttt{K.dict[V]} & Asociativní pole s klíči typu \texttt{K} a hodnotami typu \texttt{V} & Prázdné asociativní pole\\\hline
\texttt{R.fun[T\textsubscript{0} \ldots{} T\textsubscript{m}]} & Funkce přebírající argumenty typů \texttt{T\textsubscript{0}} až \texttt{T\textsubscript{m}} a vracející \texttt{R} & Funkce přebírající libovolné argumenty typů \texttt{T\textsubscript{0}} až \texttt{T\textsubscript{m}} vracející vždy výchozí hodnotu typu \texttt{R}\\\hline
\texttt{\{N\textsubscript{0} T\textsubscript{0} \ldots{} N\textsubscript{m} T\textsubscript{m}\}} & Záznam s prvky, jejichž názvy jsou \texttt{N\textsubscript{0}} až \texttt{N\textsubscript{m}} a typy jsou \texttt{T\textsubscript{0}} až \texttt{T\textsubscript{m}} & Záznam se všemi prvky nabývajícími svých výchozích hodnot\\\hline
\end{tabular}

Funkce se vytváří pomocí syntaxe lambda funkce, jež specifikuje typy argumentů a návratové hodnoty a obsahuje kód, který se při zavolání funkce vykoná. Pokud je poslední příkaz v lambda funkci vyhodnocení výrazu, navrácená hodnota je hodnota onoho výrazu, jinak se vrátí prázdná hodnota (typu \texttt{void}). Funkce se volá pomocí hranatých závorek, předají se jí argumenty odpovídajících typů a výsledkem volání funkce je hodnota, již funkce vrátila.

Záznam se vytváří stejným způsobem jako se značí typ záznamu, jen se píší hodnoty jeho prvků a ne typy. Zápis \texttt{\{N\textsubscript{0} H\textsubscript{0} \ldots{} N\textsubscript{m} H\textsubscript{m}\}} vytvoří záznam, jehož prvky budou mít názvy \texttt{N\textsubscript{0}} až \texttt{N\textsubscript{m}} a nabývají hodnot \texttt{T\textsubscript{0}} až \texttt{T\textsubscript{m}}. K prvkům záznamu se přistupuje pomocí tečky (např. \texttt{zaznam.prvek}), přičemž obsahuje-li záznam další záznamy, lze přístupy řetězit stejně jako u jmenných prostorů.

\subsubsection{Zabudované metody a operátory}
Datové typy mají svoje zabudované metody a operátory. Obojí jsou zvláštní výrazy, jež něco vykonají a vrátí nějakou hodnotu, ale liší se syntaxí. Syntaxe volání zabudovaných metod i operátorů již byla popsáná výše.

\section{Konstrukce překladače}

\section{Závěr}

\newpage
\printbibliography[heading=bibintoc, title={Použitá literatura}]
\newpage
\end{document}